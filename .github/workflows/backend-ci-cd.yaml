name: Backend CI/CD

on:
  push:
    branches:
      - main
      
env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.set-image.outputs.image }}
      tag: ${{ steps.set-image.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-image
        env:
          ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
        run: |
          ACR_LOGIN_SERVER="${ACR_LOGIN_SERVER}"
          echo "ACR_LOGIN_SERVER: ${ACR_LOGIN_SERVER}"
          if [ -z "${ACR_LOGIN_SERVER}" ]; then
            echo "ERROR: ACR_LOGIN_SERVER secret is not configured."
            echo "Set repository secret 'ACR_LOGIN_SERVER' (e.g., myregistry.azurecr.io)"
            exit 1
          fi

          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
          BRANCH=$(echo "${GITHUB_REF#refs/heads/}" | tr '/' '-')
          TAG="${BRANCH}-${SHORT_SHA}"
          IMAGE="${ACR_LOGIN_SERVER}/backend:${TAG}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT
          echo "IMAGE set to: ${IMAGE}"

      - name: show set-image outputs
        run: |
          echo "DEBUG: steps.set-image.outputs.image='${{ steps.set-image.outputs.image }}'"
          echo "DEBUG: steps.set-image.outputs.tag='${{ steps.set-image.outputs.tag }}'"

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: ACR login
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build and push image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          push: true
          tags: ${{ steps.set-image.outputs.image }}

      - name: Trivy scan image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.set-image.outputs.image }}
          format: 'table'
          scan-type: 'image'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'
          vuln-type: 'os,library'
          ignore-unfixed: true

      - name: Persist image name to artifact
        run: |
          echo "${{ steps.set-image.outputs.image }}" > image.txt
          cat image.txt
      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-image
          path: image.txt

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build image artifact (if present)
        uses: actions/download-artifact@v4
        with:
          name: build-image
          path: .

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS credentials
        uses: azure/aks-set-context@v2
        with:
          resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}

      - name: Apply namespace & service
        run: |
          echo "Creating namespace..."
          kubectl apply -f k8s/namespace.yaml
          
          # Verify namespace was created
          NS_NAME=$(kubectl get namespace capstone-project -o jsonpath='{.metadata.name}' 2>/dev/null || echo "")
          if [ -z "$NS_NAME" ]; then
            echo "ERROR: Namespace 'capstone-project' was not created!"
            exit 1
          fi
          echo "Namespace confirmed: $NS_NAME"
          
          echo "Creating service..."
          kubectl apply -f k8s/backend-svc.yaml

      - name: Deploy updated image (and create secret if not present)
        run: |
          K8S_NS="capstone-project"
          # download artifact if present (artifact will contain image.txt)
          if command -v gh >/dev/null 2>&1; then
            echo "gh CLI present"
          fi
          # attempt to use the job output first
          IMAGE="${{ needs.build-and-push.outputs.image }}"
          # if empty, try artifact (downloaded via actions/download-artifact step)
          if [ -f image.txt ]; then
            IMAGE="$(cat image.txt)"
            echo "Image loaded from artifact: $IMAGE"
          fi
          if [ -z "$IMAGE" ]; then
            echo "ERROR: IMAGE is empty!"
            exit 1
          fi
          # create secret if it doesn't exist (idempotent)
          if [ -n "${{ secrets.DB_CONN_STRING }}" ]; then
            kubectl -n $K8S_NS create secret generic backend-secrets --from-literal=db_conn="${{ secrets.DB_CONN_STRING }}" --dry-run=client -o yaml | kubectl apply -f -
            echo "Secret configured"
          else
            echo "WARNING: DB_CONN_STRING secret not set, skipping secret creation"
          fi
          sed "s|REPLACE_WITH_IMAGE|$IMAGE|g" k8s/backend-deploy.yaml > k8s/backend-deploy.tmp.yaml
          kubectl apply -f k8s/backend-deploy.tmp.yaml
      #    rm -f k8s/backend-deploy.tmp.yaml image.txt

      - name: Roll backend deployment to pick up new image
        run: |
          CURRENT=$(kubectl -n capstone-project get svc backend -o jsonpath='{.spec.selector.version}')
          if [ "$CURRENT" = "blue" ]; then
            NEXT="green"
          else
            NEXT="blue"
          fi
          echo "Deploying $NEXT backend deployment"
          echo "next=$NEXT" >> $GITHUB_OUTPUT
          
           if command -v gh >/dev/null 2>&1; then
            echo "gh CLI present"
          fi
          # attempt to use the job output first
          IMAGE="${{ needs.build-and-push.outputs.image }}"
          # if empty, try artifact (downloaded via actions/download-artifact step)
          if [ -f image.txt ]; then
            IMAGE="$(cat image.txt)"
            echo "Image loaded from artifact: $IMAGE"
          fi
          if [ -z "$IMAGE" ]; then
            echo "ERROR: IMAGE is empty!"
            exit 1
          fi

          sed "s|REPLACE_WITH_IMAGE|$IMAGE|g" k8s/backend-$NEXT.yaml > /tmp/backend.yaml
          kubectl apply -f /tmp/backend.yaml
          kubectl -n capstone-project rollout status deployment/backend-$NEXT --timeout=120s
          kubectl -n capstone-project patch svc backend \
          -p "{\"spec\":{\"selector\":{\"app\":\"backend\",\"version\":\"$NEXT\"}}}"
          echo "Deployment failed â€” traffic never switched"
          kubectl -n capstone-project delete deployment backend-$NEXT
          kubectl -n capstone-project patch svc backend \
           -p "{\"spec\":{\"selector\":{\"app\":\"backend\",\"version\":\"$CURRENT\"}}}"
